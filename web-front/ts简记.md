* 1.数组为何要用**范型**的方式？
```js
let list: Array<number> = [1, 2, 3];
```
* 2.元组---是一个数组，数组的长度和其中的每个元素的类型都已知

```js
let x: [string, number];
// Initialize it
x = ['hello', 10]; // OK
```

* 3.枚举---给一组数值起个名字，写在一起；枚举的每个元素有自动的索引或者设置的索引

```js
enum Color {Red, Green, Blue}
let c: Color = Color.Green;
let colorName: string = Color[2]; // Blue
```

* 4.Any---编译阶段不知道类型的变量，或者使用动态内容，或者第三方代码库，或者用户输入。不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查
* 5.Void---函数没有返回时就用Void

```js
function warnUser(): void {}
```

* 6.null和undefined--默认情况下null和undefined是所有类型的子类型
* 7.never---很明显，并不常用；never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。
* 8.类型推论和类型断言：

	>类型推论---定义变量的时候，没有定义类型，直接进行了赋值，然后就根据值推论出这个类型是什么
	
	>类型断言---已经定义好的联合类型，通过书写更高确定此次使用时使用的是其中哪种类型（`<string>someValue`或者`someValue as string`）
* 9. 只读属性：

	> **readonly vs const**
最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly

* 10. 接口---作用就是为这些类型命名和为你的代码或第三方代码定义契约；接口就好比一个名字，用来描述上面例子里的要求；接口能够描述JavaScript中对象拥有的各种各样的外形，除了描述带有属性的普通对象外，接口也可以描述函数类型。

* 11. 接口定义的函数类型，类型检查时，函数的参数名不需要与接口里定义的名字相匹配，函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。

* 12. 有一种类型是索引类型；索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型；当有一个索引签名之后，这个接口就是一个索引类型？
字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配

为何报错

```js
interface NumberDictionary {
  [index: string]: number;
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}
```

